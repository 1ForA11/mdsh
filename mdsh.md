#!/usr/bin/env bash
: '
<!-- ex: set ft=markdown : '; eval "$(sed -ne '/^```shell$/,/^```$/{/^```/d; p}' "$BASH_SOURCE")"; return $? # -->
# mdsh: a self-hosted Markdown-to-Shell Compiler

``mdsh`` is a compiler and interpreter for literate programs written in markdown and bash, that is itself written as a literate program in markdown and bash.

```shell main
#!/usr/bin/env bash
# ---
# This file is automatically generated from mdsh.md - DO NOT EDIT
# ---
```

It expects to run in "bash strict mode":

```shell
set -euo pipefail  # Strict mode
```

And it includes a license header in the compiled distribution (see [LICENSE](LICENSE) file for the terms that apply to this source file as well as the compiled version):

```shell mdsh main
# incorporate the LICENSE file as bash comments
source realpaths; realpath.location "$MDSH_SOURCE"
echo; sed -e '1,2d; s/^\(.\)/# \1/; s/^$/#/;' "$REPLY/LICENSE"; echo
```

**IMPORTANT**: just because a function is named `mdsh-something` and explained in this document does not make it a published API function!  If it's not documented in the README, consider it a private implementation detail

### Contents

<!-- toc -->

- [Parser](#parser)
- [Compiler](#compiler)
  * [Code Block Handling](#code-block-handling)
    + [fn-exists](#fn-exists)
    + [mdsh-rewrite](#mdsh-rewrite)
  * [Default Languages and Data Handling](#default-languages-and-data-handling)
- [Command-Line Interface](#command-line-interface)
  * [Interpreting Files](#interpreting-files)
  * [--compile (-c)](#--compile--c)
  * [--eval (-E)](#--eval--e)
  * [--out (-o) *file*](#--out--o-file)
  * [Usage Errors](#usage-errors)
  * [Help (-h and --help)](#help--h-and---help)
- [Utilities and Startup](#utilities-and-startup)
  * [mdsh-embed](#mdsh-embed)
  * [run-markdown](#run-markdown)
  * [Deprecated Functions](#deprecated-functions)
  * [Run Main](#run-main)

<!-- tocstop -->

## Parser

`mdsh-parse` is an "event-driven" mini-parser for markdown.  It takes a function name as an argument and a markdown string on stdin, and invokes the function with arguments representing "events".  Currently the only event is `fenced`, which has two extra arguments: the language of the code block, and its contents.

The `$fence` and `$indent` variables can be inspected to tell what the block's original fence string (e.g. `~~~`) was, and how deeply it was indented.  The parser implements the full [Commonmark specification for fenced code blocks](http://spec.commonmark.org/0.28/#fenced-code-blocks), including indentation-removal, fence lengths, allowed characters, etc.:

```shell
mdsh-parse() {
    local cmd=$1 lang block ln indent fence close_fence indent_remove
    local open_fence='^( {0,3})(~~~+|```+) *([^`]*)$'
    while IFS= read -r ln; do
        if [[ $ln =~ $open_fence ]]; then
            indent=${BASH_REMATCH[1]} fence=${BASH_REMATCH[2]} lang=${BASH_REMATCH[3]} block=
            close_fence="^( {0,3})$fence+ *\$" indent_remove="^${indent// / ?}"
            while IFS= read -r ln && ! [[ $ln =~ $close_fence ]]; do
                ! [[ $ln =~ $indent_remove ]] || ln=${ln#$BASH_REMATCH}; block+=$ln$'\n'
            done
            lang="${lang%"${lang##*[![:space:]]}"}"; $cmd fenced "$lang" "$block";
        fi
    done
}
```

## Compiler

### API

#### mdsh-source

`mdsh-source` compiles text from standard input, or from the file specified by `$1` (if given).  It runs in the current shell, so the input is treated as if it were contained in the same file as is currently being compiled (if any.)

```shell
mdsh-source() {
    if [[ ${1:--} != '-' ]]; then
         mdsh-parse __COMPILE__ <"$1"
    else mdsh-parse __COMPILE__
    fi
}
```

(The actual "compilation" consists simply of parsing the file contents using the `__COMPILE__` function as the event handler.)

#### mdsh-compile

`mdsh-compile` is the same as `mdsh-source`, except it's run in a subshell so that variable and function definitions from `mdsh` blocks in the supplied code can't affect the main process state.

```shell
mdsh-compile() (  # <-- force subshell to prevent escape of compile-time state
    mdsh-source "$@"
)
```

### Code Block Handling

`__COMPILE__` emits bash code for unindented, triple-backquote-fenced code blocks, by interpreting them as command blocks or looking up hook functions, and either copying out their source code (using `mdsh-rewrite`), or invoking them directly:

```shell
__COMPILE__() {
    [[ $1 == fenced && $fence == '```' && ! $indent ]] || return 0  # only unindented ``` code
    local lang="${2//[^_[:alnum:]]/_}"; # convert language to safe variable/function name
    local tag_words=($2);  # check for command blocks first
    if [[ ${tag_words[1]-} == '!'* ]]; then
        set -- "$3" "$2"; eval "${2#*!}"; return
    elif [[ ${tag_words[1]-} == '|'* ]]; then
        echo "${2#*|} <<'\`\`\`'"; printf '%s```\n' "$3"; return
    elif fn-exists mdsh-lang-$lang; then
        mdsh-rewrite mdsh-lang-$lang "{" "} <<'\`\`\`'"; printf '%s```\n' "$3"
    elif fn-exists mdsh-compile-$lang; then
        mdsh-compile-$lang "$3"
    else
        mdsh-misc "$2" "$3"
    fi

    if fn-exists mdsh-after-$lang; then
        mdsh-rewrite mdsh-after-$lang
    fi
}
```

To do that, it needs to be able to detect what functions exist, and to extract their source code.

#### fn-exists

```shell
# fn-exists: succeed if argument is a function
fn-exists() { declare -F -- "$1"; } >/dev/null
```

#### mdsh-rewrite

```shell
# Output body of func $1, optionally replacing the opening/closing { and } with $2 and $3
mdsh-rewrite() {
    declare -f $1 | sed -e '1d; 2s/^{ $/'"${2-"{"}"'/; $s/^}$/'"${3-"\}"}"'/'
}
```

### Default Languages and Data Handling

By default, `mdsh` supports only `mdsh` and `shell` blocks, with everything else handled as data.  Blocks with no language are ignored, and `mdsh main` and `shell main` blocks are only compiled if a module load is not in progress (i.e., the current file is a "main" file):

```shell
mdsh-misc()          { mdsh-data "$@"; }    # Treat unknown languages as data
mdsh-compile-()      { :; }                 # Ignore language-less blocks

mdsh-compile-mdsh()  { eval "$1"; }         # Execute `mdsh` blocks in-line
mdsh-compile-mdsh_main() { [[ $MDSH_MODULE ]] || eval "$1"; }

mdsh-compile-shell() { printf '%s' "$1"; }  # Copy `shell` blocks to the output
mdsh-compile-shell_main() { [[ $MDSH_MODULE ]] || printf '%s' "$1"; }
```

Data blocks are processed by emitting code to add the block contents to an `mdsh_raw_X` variable:

```shell
mdsh-data() {
    printf "mdsh_raw_${1//[^_[:alnum:]]/_}+=(%q)\n" "$2"
}
```

And for syntax highlighting convenience, `shell mdsh` blocks and `shell mdsh main` blocks are treated as `mdsh` and `mdsh main` blocks, respectively:

```shell
mdsh-compile-shell_mdsh() {
    indent= fence='```' __COMPILE__ fenced mdsh "$1"
}
mdsh-compile-shell_mdsh_main() {
    indent= fence='```' __COMPILE__ fenced "mdsh main" "$1"
}
```

## Command-Line Interface

The command line interface looks for functions named `mdsh.OPT` to process options of a matching name, and gives a usage error if such an option isn't found.  An option of `--` means "run the file that follows", while a `-` by itself is interpreted as "interpret standard input".  A non-option argument is treated as a file to interpret.  Multiple short options are processed by splitting them into single options.

```shell
# Main program: check for arguments and run markdown script
mdsh-main() {
    (($#)) || mdsh-error "Usage: %s [--out FILE] [ --compile | --eval ] markdownfile [args...]" "${0#*/}"
    case "$1" in
    --) mdsh-interpret "${@:2}" ;;
    --*|-?) fn-exists "mdsh.$1" || mdsh-error "%s: unrecognized option: %s" "${0#*/}" "$1"
        "mdsh.$1" "${@:2}"
        ;;
    -??*) mdsh-main "${1::2}" "-${1:2}" "${@:2}" ;;  # split '-abc' into '-a -bc' and recurse
    *)  mdsh-interpret "$@" ;;
    esac
}
```

### Interpreting Files

As described in the documentation, markdown files are run with an empty  `$0` and `$BASH_SOURCE`, but with `$MDSH_ZERO` set to the source file.  This is done by exec-ing bash with an immediate command to eval the compiled version of the source file.

```shell
# Run markdown file as main program, with $0 == $BASH_SOURCE == "" and
# MDSH_ZERO pointing to the original $0.

function mdsh-interpret() {
    printf -v cmd 'eval "$(%q --compile %q)"' "$0" "$1"
    MDSH_ZERO="$1" exec bash -c "$cmd" "" "${@:2}"
}
```

### --compile (-c)

Compile one or more files, appending the results to stdout.  `mdsh` blocks in each file will see an `$MDSH_SOURCE` that points to their filename (which may just be a `-`).

```shell
mdsh.--compile() {
    (($#)) || mdsh-error "Usage: %s --compile FILENAME..." "${0#*/}"
    ! fn-exists mdsh:file-header || mdsh:file-header
    for f; do MDSH_SOURCE=$f mdsh-compile "$f"; done
    ! fn-exists mdsh:file-footer || mdsh:file-footer
}

mdsh.-c() { mdsh.--compile "$@"; }
```

### --eval (-E)

Compile one file, which *cannot* be stdin.  Adds a suffix to ensure the compiled code returns, allowing use in shelldown headers of files that are source-able.

```shell
mdsh.--eval() {
    (($# == 1)) && [[ $1 != - ]] ||
        mdsh-error "Usage: %s --eval FILENAME" "${0#*/}"
    mdsh.--compile "$1"
    echo "__status=\$? eval 'return \$__status || exit \$__status' 2>/dev/null"
}

mdsh.-E() { mdsh.--eval "$@"; }
```

### --out (-o) *file*

Send output to the named file, overwriting it in place if and only if the compilation succeeds without error.

```shell
mdsh.--out() {
    if REPLY=("$(mdsh-main "${@:2}")"); then
        echo "$REPLY" >"$1";
    else exit $?;
    fi
}

mdsh.-o() { mdsh.--out "$@"; }
```

### Usage Errors

```shell
# mdsh-error: printf args to stderr and exit w/EX_USAGE (code 64)
mdsh-error() { printf "$1\n" "${@:2}" >&2; exit 64; }
```

### Help (-h and --help)

```shell
mdsh.--help() {
    printf "Usage: %s [--out FILE] [ --compile | --eval ] markdownfile [args...]\n" "${0#*/}"
    echo -e '
Run and/or compile code blocks from markdownfile(s) to bash.
Use a filename of `-` to run or compile from stdin.

Options:
  -h, --help                Show this help message and exit
  -c, --compile MDFILE...   Compile MDFILE(s) to bash and output on stdout.
  -E, --eval MDFILE         Compile one file w/a shelldown-support footer line\n'
}

mdsh.-h() { mdsh.--help "$@"; }
```

## Utilities and Startup

### mdsh-embed

Embed a bash module's source in such a way that it believes itself to be `source`d when executed.

```shell
mdsh-embed() {
    local f=$1 base=${1##*/}; local boundary="# --- EOF $base ---" contents ctr=
    [[ $f == */* && -f $f ]] || f=$(command -v "$f") || {
        echo "Can't find module $1" >&2; return 69  # EX_UNAVAILABLE
    }
    contents=$'\n'$(<"$f")$'\n'
    while [[ $contents == *$'\n'"$boundary"$'\n'* ]]; do
        let ctr++; boundary="# --- EOF $base.$ctr ---"
    done
    printf $'{ if [[ $OSTYPE != cygwin && $OSTYPE != msys && -e /dev/fd/0 ]]; then source /dev/fd/0; else source <(cat); fi; } <<\'%s\'%s%s\n' "$boundary" "$contents" "$boundary"
}
```

### mdsh-module

`mdsh-module` *modulename cmd [args...]* will run *cmd args...* if it is the first call to `mdsh-module` for that *modulename*.  The *cmd* should usually be `mdsh-source` or `mdsh-embed`, to include markdown modules or shell script modules, respectively, but it can be any command or function.  During execution of *cmd*, `MDSH_MODULE` will be set to *modulename*, allowing the running code to know it's being used as a module, potentially compiling itself differently.  (Normally, `MDSH_MODULE` is empty.)

```shell
MDSH_LOADED_MODULES=
MDSH_MODULE=

mdsh-module() {
    if ! [[ $MDSH_LOADED_MODULES == *"<$1>"* ]]; then
        MDSH_LOADED_MODULES+="<$1>"; local MDSH_MODULE=$1
        "${@:2}"
    fi
}
```

### mdsh-make

Compile file `$1` to file `$2` if the destination doesn't exist or doesn't have the same timestamp.  Compilation happens in a subshell, and any additional arguments are treated as a command to be run inside the subshell before the compilation.  (They're only run if compilation is about to occur.)  If compilation happens and is successful, `$2` is touched to the same timestamp as `$1`.

```shell
mdsh-make() {
    [[ -f "$2" && "$(stat -c %y "$1")" == "$(stat -c %y "$2")" ]] || (
        "${@:3}" && mdsh-main --out "$2" --compile "$1" && touch -r "$1" "$2"
    )
}
```

### run-markdown

```shell
# run-markdown file args...
# Compile `file` and source the result, passing along any positional arguments
run-markdown() { source <(mdsh-source "${1--}") "${@:2}"; }
```

### Deprecated Functions

```shell
# --- BEGIN DEPRECATED CODE ---
markdown-to-shell() {
    local arg cmd="$1" any='[^'"'"']\{1,\}'; local lang="${2:-$any}"

    # Build up an "or" of languages, if more than one given
    if (($#>2)); then printf -v lang '\|%q' "${@:3}"; lang="$2$lang"; fi
    extract-markdown '\('"$lang"'\)' "$cmd"' <<'"'"'```'"' '\\2'" '```'
}
extract-markdown() { extract-between '^```'"$1"'$' '^```$' "${@:2}"; }
extract-between() { sed -ne '/'"$1"'/,/'"$2"'/ { s/\('"$1"'\)/'"${3-}"'/; s/'"$2"'/'"${4-}"'/; p;}'; }
# --- END DEPRECATED CODE ---

```

### Run Main

```shell
# --- All functions have been defined, main script starts here! ---

# check bash-source and run main only if directly executing
if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then mdsh-main "$@"; exit $?; fi
```
