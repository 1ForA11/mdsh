#!/usr/bin/env bash
# Strict mode
set -euo pipefail

# Main program: check for arguments and run markdown script

mdsh-main() {
    (($# > 0)) || mdsh-error "Usage: $0 markdownfile args..."
    run-markdown "$@"
}


# run-markdown file args...
#
# Extract code blocks from `file` and run them, saving args as $ARGV

run-markdown() {
    local ARGV=("$@")  # ARGV[0] = file, ARGV[1...] = args...
    source <(markdown-to-shell RUN <"$1");
}

# RUN language
#
# Run a block written in `language` from stdin.  Executes mdsh-lang-$1 if such
# a function exists, otherwise it saves the block to a temp file.  If an
# after-hook function (mdsh-after-$1) exists, run it afterwards.

RUN() {
    if fn-exists "mdsh-lang-$1"; then
        mdsh-lang-$1;
    else
        mdsh-create-tempdir; cat >>"$MDSH_TMP/unprocessed.$1"
    fi
    if fn-exists "mdsh-after-$1"; then mdsh-after-$1; fi
}

# Interpret shell code by sourcing it, passing in any positional arguments from
# run-markdown after the filename

mdsh-lang-shell() { source <(cat) "${ARGV[@]:1}" ; }

# markdown-to-shell cmd [lang...]
#
# Process markdown from stdin, converting triple-backquoted code blocks to
# `cmd langtag <<heredoc` blocks and outputting the result on stdout.
#
# Arguments $2 and on are language tag regexes in sed syntax; only matching
# blocks are processed.  If no languages are given, all code blocks with a tag
# are processed.

markdown-to-shell() {
    local arg cmd="$1" lang="${2:-.\\+}"

    # Build up an "or" of languages
    for arg in "${@:3}"; do
        lang="$lang"'\|'"$arg"
    done

    extract-markdown '\('"$lang"'\)' "$cmd"' \2 <<'"'"'```'"'" '```'
}

# extract-markdown tagregex head tail
#
# Process markdown from stdin, outputting tagged code blocks matching tagregex,
# with the block-start and end lines replaced by `head` and `tail`.  `head` can
# contain sed backreferences to groups in `tagregex`.

extract-markdown() {
    extract-between '^```'"$1"'$' '^```$' "${@:2}";
}


# extract-between start end head tail
#
# Ouptut lines between start/end pairs, with the start and end replaced by
# head and tail.  The head and tail can contain sed backrefs to start and end.

extract-between() {
    sed -ne '/'"$1"'/,/'"$2"'/ { s/\('"$1"'\)/'"${3-}"'/; s/'"$2"'/'"${4-}"'/; p}';
}


# INCLUDE file.ext args...
#
# Process a file according to its longest extension matching an existing
# `mdsh-include-ext` function.  (So, x.tar.gz would first try to run
# `mdsh-include-tar.gz`, then `mdsh-include-gz`.)  All arguments are forwarded
# to the inclusion function.

INCLUDE() {
    [[ -f "$1" ]] || mdsh-error "INCLUDE file $1 does not exist";
    local base="$(basename "$1")"
    local ext="${base#*.}"
    while [[ "$base" != "$ext" ]]; do
        if fn-exists "mdsh-include-$ext"; then
            mdsh-include-$ext "$@"
            return 0
        fi
        base="$ext"; ext="${base#*.}"
    done
    mdsh-error "Unrecognized type $ext for INCLUDEd file $1"
}

# Include markdown files by running them as part of the current script

mdsh-include-md()       { run-markdown "$@"; }
mdsh-include-mdown()    { run-markdown "$@"; }
mdsh-include-markdown() { run-markdown "$@"; }


# mdsh-error: echo arguments to stderr and return failure
# Can be overridden by extending scripts.

mdsh-error() {
    echo "$@" >&2; return 1
}

# fn-exists: succeed if argument is a function

fn-exists() {
    [[ "$(type -t "$1")" == "function" ]]
}

# Set up $MDSH_TMP as a temporary directory, and arrange for it to be deleted
# on script exit

mdsh-create-tempdir() {
    if [[ -z "${MDSH_TMP-}" ]] || [[ ! -d "${MDSH_TMP-}" ]]; then
        MDSH_TMP="$(mktemp -t -d mdsh-XXXXXXXXXX)"
    fi
}


# Delete $MDSH_TMP if present, and unset MDSH_TMP

mdsh-delete-tempdir() {
    if [[ -n "${MDSH_TMP-}" ]] && [[ -d "${MDSH_TMP-}" ]] ; then
        rm -rf "$MDSH_TMP"
    fi
    unset MDSH_TMP
}

# Post-script teardown processing: can be overridden to perform other actions
# at exit, but then the new definition should still mdsh-delete-tempdir!

mdsh-teardown() {
    mdsh-delete-tempdir
}


# --- All functions have been defined, main script starts here! ---

# Initialize MDSH_TMP and setup teardown trap
MDSH_TMP=
trap mdsh-teardown EXIT


# check bash-source and run main only if directly executing

if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then
    mdsh-main "$@"
    exit $?
fi

