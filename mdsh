#!/usr/bin/env bash

# LICENSE
# -------
#
# `mdsh` is copyright 2017 PJ Eby, and
# MIT-licensed as follows:
#
# Permission is hereby granted, free of
# charge, to any person obtaining a copy
# of this software and associated
# documentation files (the "Software"),
# to deal in the Software without
# restriction, including without
# limitation the rights to use, copy,
# modify, merge, publish, distribute,
# sublicense, and/or sell copies of the
# Software, and to permit persons to
# whom the Software is furnished to do
# so, subject to the following
# conditions:
#
# The above copyright notice and this
# permission notice shall be included in
# all copies or substantial portions of
# the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS",
# WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT OWNERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

set -euo pipefail  # Strict mode

# Main program: check for arguments and run markdown script
mdsh-main() {
    (($#)) || mdsh-error "Usage: %s [ --compile | --eval ] markdownfile [args...]" "$0"
    case "$1" in
    --) shift; mdsh-run-zero "$@" ;;
    -)  mdsh-run-zero "$@" ;;
    -*) fn-exists "mdsh.$1" || mdsh-error "%s: unrecognized option: %s" "$0" "$1"
        "mdsh.$1" "${@:2}"
        ;;
    *)  mdsh-run-zero "$@" ;;
    esac
}

mdsh.--help() {
    printf "Usage: %s [ --compile | --eval ] markdownfile [args...]\n" "$0"
    echo -e '
Run and/or compile code blocks from markdownfile(s) to bash.
Use a filename of `-` to run or compile from stdin.

Options:
  -h, --help                Show this help message and exit
  -c, --compile MDFILE...   Compile MDFILE(s) to bash and output on stdout.
  -E, --eval MDFILE...      Compile, but add a shelldown-support footer line\n'
}

mdsh.--eval() {
    mdsh.--compile "$@"
    echo $'__status=$? eval \'return $__status || exit $__status\' 2>/dev/null'
}

mdsh.--compile() {
    (($#)) || mdsh-error "Usage: %s [ --compile | --eval ] FILENAME..." "$0"
    for f; do mdsh-compile "$f"; done
}

mdsh.-h() { mdsh.--help "$@"; }
mdsh.-c() { mdsh.--compile "$@"; }
mdsh.-E() { mdsh.--eval "$@"; }

# Run markdown file as main program, with $0 == $BASH_SOURCE == "" and
# MDSH_ZERO pointing to the original $0.

function mdsh-run-zero() {
    printf -v cmd 'eval "$(%q --compile %q)"' "$0" "$1"
    MDSH_ZERO="$1" exec bash -c "$cmd" "" "${@:2}"
}

# run-markdown file args...
# Compile `file` and source the result, passing along any positional arguments

run-markdown() { source <(mdsh-compile <"$1") "${@:2}"; }

mdsh-compile() (  # <-- force subshell to prevent escape of compile-time state
    (($#)) && [[ $1 != '-' ]] && exec <"$1"  # take a file or stdin
    eval "$(markdown-to-shell __COMPILE__)";
)

mdsh-compile-mdsh() { eval "$(mdsh-cat)"; }
mdsh-compile-shell() { mdsh-cat; }

__COMPILE__() {
    local lang="${1//[^_[:alnum:]]/_}"
    if fn-exists mdsh-lang-$lang; then
        mdsh-rewrite mdsh-lang-$lang "{" "} <<'\`\`\`'"; mdsh-cat; echo '```'
    elif fn-exists mdsh-compile-$lang; then
        mdsh-compile-$lang
    else
        mdsh-slurp; printf "mdsh_raw_$lang+=(%q)\n" "$REPLY"
    fi
    if fn-exists mdsh-after-$lang; then mdsh-rewrite mdsh-after-$lang; fi
}

mdsh-rewrite() {
    declare -f $1 | sed -e '1d; 2s/^{ $/'"${2-"{"}"'/; $s/^}$/'"${3-"\}"}"'/'
}

# Faster, fork-free replacements for text-only, small-file $(cat) and cat
mdsh-slurp() { ! read -rd '' || mdsh-error "NUL encountered in markdown block"; }
mdsh-cat()   { mdsh-slurp; printf "%s" "$REPLY"; }

# fn-exists: succeed if argument is a function
fn-exists() { declare -F -- "$1"; } >/dev/null

# mdsh-error: printf args to stderr and exit w/EX_USAGE (code 64)
mdsh-error() { printf "$1\n" "${@:2}" >&2; exit 64; }

# markdown-to-shell cmd [lang...]
#
# Process markdown from stdin, converting triple-backquoted code blocks to
# `cmd <<heredoc 'langtag'` blocks and outputting the result on stdout.
#
# Arguments $2 and on are language tag regexes in sed syntax; only matching
# blocks are processed.  If no languages are given, all code blocks with a tag
# are processed.  (Except for ones containing any single-quote characters.)
markdown-to-shell() {
    local arg cmd="$1" any='[^'"'"']\{1,\}'; local lang="${2:-$any}"

    # Build up an "or" of languages, if more than one given
    if (($#>2)); then printf -v lang '\|%q' "${@:3}"; lang="$2$lang"; fi
    extract-markdown '\('"$lang"'\)' "$cmd"' <<'"'"'```'"' '\\2'" '```'
}

# extract-markdown tagregex head tail
#
# Process markdown from stdin, outputting tagged code blocks matching tagregex,
# with the block-start and end lines replaced by `head` and `tail`.  `head` can
# contain sed backreferences to groups in `tagregex`.
extract-markdown() { extract-between '^```'"$1"'$' '^```$' "${@:2}"; }

# extract-between start end head tail
#
# Ouptut lines between start/end pairs, with the start and end replaced by
# head and tail.  The head and tail can contain sed backrefs to start and end.
extract-between() { sed -ne '/'"$1"'/,/'"$2"'/ { s/\('"$1"'\)/'"${3-}"'/; s/'"$2"'/'"${4-}"'/; p;}'; }


# --- All functions have been defined, main script starts here! ---

# check bash-source and run main only if directly executing
if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then mdsh-main "$@"; exit $?; fi

