#!/usr/bin/env bash

# LICENSE
# -------
#
# `mdsh` is copyright 2017 PJ Eby, and
# MIT-licensed as follows:
#
# Permission is hereby granted, free of
# charge, to any person obtaining a copy
# of this software and associated
# documentation files (the "Software"),
# to deal in the Software without
# restriction, including without
# limitation the rights to use, copy,
# modify, merge, publish, distribute,
# sublicense, and/or sell copies of the
# Software, and to permit persons to
# whom the Software is furnished to do
# so, subject to the following
# conditions:
#
# The above copyright notice and this
# permission notice shall be included in
# all copies or substantial portions of
# the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS",
# WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT OWNERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

# Strict mode
set -euo pipefail

# Main program: check for arguments and run markdown script

mdsh-main() {
    (($# > 0)) || mdsh-error "Usage: $0 markdownfile args..."
    run-markdown "$@"
}


# run-markdown file args...
#
# Extract code blocks from `file` and run them

run-markdown() {
    local __ARGV=("$@")  # ARGV[0] = file, ARGV[1...] = args...
    source <(markdown-to-shell RUN <"$1");
}

# RUN language
#
# Run a block written in `language` from stdin.  Executes mdsh-lang-$1 if such
# a function exists, otherwise it saves the block to a temp file.  If an
# after-hook function (mdsh-after-$1) exists, run it afterwards.

RUN() {
    if fn-exists "mdsh-lang-$1"; then
        mdsh-lang-$1;
    else
        mdsh-create-tempdir; cat >>"$MDSH_TMP/unprocessed.$1"
    fi
    if fn-exists "mdsh-after-$1"; then mdsh-after-$1; fi
}

# Interpret shell code by sourcing it, passing in any positional arguments from
# run-markdown after the filename

mdsh-lang-shell() { source <(cat) "${__ARGV[@]:1}" ; }
mdsh-lang-mdsh()  { source <(cat) ; }

# markdown-to-shell cmd [lang...]
#
# Process markdown from stdin, converting triple-backquoted code blocks to
# `cmd langtag <<heredoc` blocks and outputting the result on stdout.
#
# Arguments $2 and on are language tag regexes in sed syntax; only matching
# blocks are processed.  If no languages are given, all code blocks with a tag
# are processed.

markdown-to-shell() {
    local arg cmd="$1" lang="${2:-.\\+}"

    # Build up an "or" of languages
    for arg in "${@:3}"; do
        lang="$lang"'\|'"$arg"
    done

    extract-markdown '\('"$lang"'\)' "$cmd"' \2 <<'"'"'```'"'" '```'
}

# extract-markdown tagregex head tail
#
# Process markdown from stdin, outputting tagged code blocks matching tagregex,
# with the block-start and end lines replaced by `head` and `tail`.  `head` can
# contain sed backreferences to groups in `tagregex`.

extract-markdown() {
    extract-between '^```'"$1"'$' '^```$' "${@:2}";
}


# extract-between start end head tail
#
# Ouptut lines between start/end pairs, with the start and end replaced by
# head and tail.  The head and tail can contain sed backrefs to start and end.

extract-between() {
    sed -ne '/'"$1"'/,/'"$2"'/ { s/\('"$1"'\)/'"${3-}"'/; s/'"$2"'/'"${4-}"'/; p}';
}


# mdsh-error: echo arguments to stderr and return failure
# Can be overridden by extending scripts.

mdsh-error() {
    echo "$@" >&2; return 1
}

# fn-exists: succeed if argument is a function

fn-exists() {
    [[ "$(type -t "$1")" == "function" ]]
}

# Set up $MDSH_TMP as a temporary directory, and arrange for it to be deleted
# on script exit

mdsh-create-tempdir() {
    if [[ -z "${MDSH_TMP-}" ]] || [[ ! -d "${MDSH_TMP-}" ]]; then
        MDSH_TMP="$(mktemp -t -d mdsh-XXXXXXXXXX)"
    fi
}


# Delete $MDSH_TMP if present, and unset MDSH_TMP

mdsh-delete-tempdir() {
    if [[ -n "${MDSH_TMP-}" ]] && [[ -d "${MDSH_TMP-}" ]] ; then
        rm -rf "$MDSH_TMP"
    fi
    unset MDSH_TMP
}

# Post-script teardown processing: can be overridden to perform other actions
# at exit, but then the new definition should still mdsh-delete-tempdir!

mdsh-teardown() {
    mdsh-delete-tempdir
}



# --- All functions have been defined, main script starts here! ---

# Initialize MDSH_TMP and setup teardown trap
MDSH_TMP=
trap mdsh-teardown EXIT


# check bash-source and run main only if directly executing

if [[ "$0" == "${BASH_SOURCE[0]}" ]]; then
    mdsh-main "$@"
    exit $?
fi




























